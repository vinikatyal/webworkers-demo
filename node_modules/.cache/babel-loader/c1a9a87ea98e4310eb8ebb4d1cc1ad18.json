{"ast":null,"code":"/**\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\n\nconst isObject = val => typeof val === \"object\" && val !== null || typeof val === \"function\";\n/**\r\n * Internal transfer handle to handle objects marked to proxy.\r\n */\n\n\nconst proxyTransferHandler = {\n  canHandle: val => isObject(val) && val[proxyMarker],\n\n  serialize(obj) {\n    const {\n      port1,\n      port2\n    } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  }\n\n};\n/**\r\n * Internal transfer handler to handle thrown exceptions.\r\n */\n\nconst throwTransferHandler = {\n  canHandle: value => isObject(value) && throwMarker in value,\n\n  serialize({\n    value\n  }) {\n    let serialized;\n\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack\n        }\n      };\n    } else {\n      serialized = {\n        isError: false,\n        value\n      };\n    }\n\n    return [serialized, []];\n  },\n\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(new Error(serialized.value.message), serialized.value);\n    }\n\n    throw serialized.value;\n  }\n\n};\n/**\r\n * Allows customizing the serialization of certain values.\r\n */\n\nconst transferHandlers = new Map([[\"proxy\", proxyTransferHandler], [\"throw\", throwTransferHandler]]);\n\nfunction expose(obj, ep = self) {\n  ep.addEventListener(\"message\", function callback(ev) {\n    if (!ev || !ev.data) {\n      return;\n    }\n\n    const {\n      id,\n      type,\n      path\n    } = Object.assign({\n      path: []\n    }, ev.data);\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n\n      switch (type) {\n        case 0\n        /* GET */\n        :\n          {\n            returnValue = rawValue;\n          }\n          break;\n\n        case 1\n        /* SET */\n        :\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n\n        case 2\n        /* APPLY */\n        :\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n\n        case 3\n        /* CONSTRUCT */\n        :\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n\n        case 4\n        /* ENDPOINT */\n        :\n          {\n            const {\n              port1,\n              port2\n            } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n\n        case 5\n        /* RELEASE */\n        :\n          {\n            returnValue = undefined;\n          }\n          break;\n      }\n    } catch (value) {\n      returnValue = {\n        value,\n        [throwMarker]: 0\n      };\n    }\n\n    Promise.resolve(returnValue).catch(value => {\n      return {\n        value,\n        [throwMarker]: 0\n      };\n    }).then(returnValue => {\n      const [wireValue, transferables] = toWireValue(returnValue);\n      ep.postMessage(Object.assign(Object.assign({}, wireValue), {\n        id\n      }), transferables);\n\n      if (type === 5\n      /* RELEASE */\n      ) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback);\n          closeEndPoint(ep);\n        }\n    });\n  });\n\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint) {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nfunction wrap(ep, target) {\n  return createProxy(ep, [], target);\n}\n\nfunction throwIfProxyReleased(isReleased) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction createProxy(ep, path = [], target = function () {}) {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n\n      if (prop === releaseProxy) {\n        return () => {\n          return requestResponseMessage(ep, {\n            type: 5\n            /* RELEASE */\n            ,\n            path: path.map(p => p.toString())\n          }).then(() => {\n            closeEndPoint(ep);\n            isProxyReleased = true;\n          });\n        };\n      }\n\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return {\n            then: () => proxy\n          };\n        }\n\n        const r = requestResponseMessage(ep, {\n          type: 0\n          /* GET */\n          ,\n          path: path.map(p => p.toString())\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n\n      return createProxy(ep, [...path, prop]);\n    },\n\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased); // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(ep, {\n        type: 1\n        /* SET */\n        ,\n        path: [...path, prop].map(p => p.toString()),\n        value\n      }, transferables).then(fromWireValue);\n    },\n\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n\n      if (last === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: 4\n          /* ENDPOINT */\n\n        }).then(fromWireValue);\n      } // We just pretend that `bind()` didn’t happen.\n\n\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(ep, {\n        type: 2\n        /* APPLY */\n        ,\n        path: path.map(p => p.toString()),\n        argumentList\n      }, transferables).then(fromWireValue);\n    },\n\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(ep, {\n        type: 3\n        /* CONSTRUCT */\n        ,\n        path: path.map(p => p.toString()),\n        argumentList\n      }, transferables).then(fromWireValue);\n    }\n\n  });\n  return proxy;\n}\n\nfunction myFlat(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList) {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map(v => v[0]), myFlat(processed.map(v => v[1]))];\n}\n\nconst transferCache = new WeakMap();\n\nfunction transfer(obj, transfers) {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nfunction proxy(obj) {\n  return Object.assign(obj, {\n    [proxyMarker]: true\n  });\n}\n\nfunction windowEndpoint(w, context = self, targetOrigin = \"*\") {\n  return {\n    postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context)\n  };\n}\n\nfunction toWireValue(value) {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [{\n        type: 3\n        /* HANDLER */\n        ,\n        name,\n        value: serializedValue\n      }, transferables];\n    }\n  }\n\n  return [{\n    type: 0\n    /* RAW */\n    ,\n    value\n  }, transferCache.get(value) || []];\n}\n\nfunction fromWireValue(value) {\n  switch (value.type) {\n    case 3\n    /* HANDLER */\n    :\n      return transferHandlers.get(value.name).deserialize(value.value);\n\n    case 0\n    /* RAW */\n    :\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(ep, msg, transfers) {\n  return new Promise(resolve => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n\n      ep.removeEventListener(\"message\", l);\n      resolve(ev.data);\n    });\n\n    if (ep.start) {\n      ep.start();\n    }\n\n    ep.postMessage(Object.assign({\n      id\n    }, msg), transfers);\n  });\n}\n\nfunction generateUUID() {\n  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join(\"-\");\n}\n\nexport { createEndpoint, expose, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };","map":{"version":3,"sources":["../../src/comlink.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n} from \"./protocol\";\nexport { Endpoint };\n\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\n\nconst throwMarker = Symbol(\"Comlink.thrown\");\n\n/**\n * Interface of values that were marked to be proxied with `comlink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, comlink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : Promisify<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked\n  ? Local<T>\n  : Unpromisify<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Comlink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special comlink methods available on each proxy returned by `Comlink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => void;\n}\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Comlink.wrap()` or `Comlink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => Promisify<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): Promisify<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special comlink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Expresses that a type can be either a sync or async.\n */\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, comlink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<Unpromisify<TInstance>>>;\n        }\n      : unknown);\n\nconst isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value\n      );\n    }\n    throw serialized.value;\n  },\n};\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>([\n  [\"proxy\", proxyTransferHandler],\n  [\"throw\", throwTransferHandler],\n]);\n\nexport function expose(obj: any, ep: Endpoint = self as any) {\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    const { id, type, path } = {\n      path: [] as string[],\n      ...(ev.data as Message),\n    };\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n      switch (type) {\n        case MessageType.GET:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case MessageType.SET:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case MessageType.APPLY:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case MessageType.CONSTRUCT:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case MessageType.ENDPOINT:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case MessageType.RELEASE:\n          {\n            returnValue = undefined;\n          }\n          break;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    Promise.resolve(returnValue)\n      .catch((value) => {\n        return { value, [throwMarker]: 0 };\n      })\n      .then((returnValue) => {\n        const [wireValue, transferables] = toWireValue(returnValue);\n        ep.postMessage({ ...wireValue, id }, transferables);\n        if (type === MessageType.RELEASE) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback as any);\n          closeEndPoint(ep);\n        }\n      });\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  return createProxy<T>(ep, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction createProxy<T>(\n  ep: Endpoint,\n  path: (string | number | symbol)[] = [],\n  target: object = function () {}\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          return requestResponseMessage(ep, {\n            type: MessageType.RELEASE,\n            path: path.map((p) => p.toString()),\n          }).then(() => {\n            closeEndPoint(ep);\n            isProxyReleased = true;\n          });\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy };\n        }\n        const r = requestResponseMessage(ep, {\n          type: MessageType.GET,\n          path: path.map((p) => p.toString()),\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables\n      ).then(fromWireValue) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT,\n        }).then(fromWireValue);\n      }\n      // We just pretend that `bind()` didn’t happen.\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.APPLY,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n  });\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer(obj: any, transfers: Transferable[]) {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport function proxy<T>(obj: T): T & ProxyMarked {\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = self,\n  targetOrigin = \"*\"\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: WireValueType.HANDLER,\n          name,\n          value: serializedValue,\n        },\n        transferables,\n      ];\n    }\n  }\n  return [\n    {\n      type: WireValueType.RAW,\n      value,\n    },\n    transferCache.get(value) || [],\n  ];\n}\n\nfunction fromWireValue(value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[]\n): Promise<WireValue> {\n  return new Promise((resolve) => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n      ep.removeEventListener(\"message\", l as any);\n      resolve(ev.data);\n    } as any);\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage({ id, ...msg }, transfers);\n  });\n}\n\nfunction generateUUID(): string {\n  return new Array(4)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n    .join(\"-\");\n}\n"]},"metadata":{},"sourceType":"module"}